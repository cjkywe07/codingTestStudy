# 02 List

1. 리스트(List)

순서를 가지고 데이터를 저장하는 자료구조

구현 방법
    Array list
        Static Array
        Dynamic Array (파이썬의 리스트)

    Linked list
        Node

--------------------------------------------------------------------------------

2. 배열(Array / Static Array)

- 고정된 저장 공간 (fixed size) - 선언 이후에 사이즈 변경 불가
- 순차적인 데이터 저장 (ordered)

random access
    메모리에 저장된 데이터에 접근하려면 주소값을 알아야 하는데
    배열변수는 자신이 할당받은 메모리의 첫 번째 주소값을 가리키고,
    데이터는 연속적/순차적으로 자장되어있기 때문에 첫 주소값만 안다면
    어떤 index에도 즉시 접근 가능
    -> 데이터 접근 : O(1)

    하지만, linked list는 데이터가 메모리상에서 연속적/순차적으로 저장되어있지 않기 때문에
    raddom access가 불가능하고 n번째 데이터에 접근하려면 n번의 연산을 해야함
    -> 데이터 접근 : O(n)

static array의 한계
    (1) 선언 시에 정한 사이즈보다 많은 데이터를 저장해야 하는 경우 공간이 남아있지 않아 문제 발생
    (2) 그렇다고 매번 큰 배열을 선언한다면 그만큼 메모리 비효율 발생
    -> 이러한 문제점을 해결할 수 있는 방법이 dynamic array

--------------------------------------------------------------------------------

3. 동적 배열(Dynamic Array)

선언 이후에도 배열의 크기 변경 가능

resizing 과정
    기존 배열보다 2배 정도 큰 배열을 새로 선언한 후(더블링)
    그곳으로 데이터를 옯기고 -> O(n)
    기존의 배열을 메모리에서 삭제(free)

Dynamic Array 사용법
    파이썬에서서는 dynamic array를 list 자료형으로 이미 구현해 두었기 때문에
    list를 구현하는 방법이 아닌, 리스트의 연산들과 연산들의 시간 복잡도를 알아야 함

Dynamic Array 시간복잡도
    선언/초기화 : O(n)
    접근/수정   : O(1)
    -------------------
    맨뒤에 추가 : O(1) - 리사이징은 O(n)이지만, 가끔만 발생하므로, 분할상황기법을 통해 O(1)이라고 함
    중간에 추가 : O(n)
    맨앞에 추가 : O(n)
    -------------------
    맨뒤 삭제   : O(1)
    중간 삭제   : O(n)
    맨앞 삭제   : O(n)

★코테 적용 방법★
    배열의 다양한 활용

    (1) 반복문
    (2) sort & two pointer

--------------------------------------------------------------------------------

4. 연결 리스트(Linked List)

- Node라는 구조체가 연결되는 형식으로 데이터가 저장되는 자료구조
- 메모리상에서는 비연속적으로 저장되어 있지만, 각각의 node가
  next node의 메모리 주소값을 가리킴으로써 논리적인 연속성을 갖게 됨
- 메모리상에서 연속성을 유지하지 않아도 되므로 메모리 사용이 좀 더 자유로움
- 다만 next node의 주소값도 추가적으로 저장해야 하므로 데이터 하나당 차지하는 메모리가 더 커지게 됨

Linked List 시간복잡도
    접근/수정   : O(n)
    -------------------
    맨앞에 추가 : O(1)
    중간에 추가 : O(n)
    맨뒤에 추가 : 반복문 - O(n) / head,tail - O(1)
    -------------------
    맨앞 삭제   : O(1)
    중간 삭제   : O(n)
    맨뒤 삭제   : 반복문 - O(n) / head,tail - O(1)

★코테 적용 방법★
    Linked List이 다양한 활용
    
    (1) linked list 자유자재 구현 (선형 자료구조 + 중간에 데이터 추가/삭제 용이)
    (2) tree & graph 에 활용

--------------------------------------------------------------------------------

문제 해결 순서
    (1) 문제 이해
        input/output 확인
        input size N 확인 - 시간복잡도 계산하기 위한 N 또는 M 파악
        제약조건 확인 - 시간복잡도 제한 확인 (알고리즘 선택에 활용)
        예상 가능한 오류 파악 - 입력값의 범위 / stack overflow 등

    (2) 접근 방법
        직관적으로 생각
            보통 완전탐색으로 시작
            문제 상황을 단순화하여 생각
            문제 상황을 극한화하여 상각
            
        자료구조와 알고리즘 활용
            문제 이해에서 파악한 내용을 토대로 어떤 자료구조를 사용하는 게 가장 적합한지 결정
            대놓고 특정 자료구조와 알고리즘을 묻는 문제도 많음
            자료구조에 따라 선택할 수 있는 알고리즘을 문제에 적용

        메모리 사용
            시간복잡도를 줄이기 위해 메모리를 사용하는 방법
            대표적으로 해시테이블

    (3) 코드 설계

    (4) 코드 구현
